(function() {var GLANCE=window.GLANCE;GLANCE.Video.drawTrackingData=!1;
GLANCE.Video.GlanceVideoBGEffects=class{constructor(a){this.glanceVideoSource=a;this.detectionBuffer2dCtx=this.detectionBuffer=this.maskBuffer2dCtx=this.maskBuffer=this.renderBufferWebGLCtx=this.renderedBuffer=null;this.bgBlurEnabled=!0;this.bgEffectType="blur";this.bgColor="#2E9CDD";this.bgImageElement=null;this.bgImageLoaded=!1;this.imageFillBitmap=null;this.detectionMaxDimension=256;this.requestedDetectionAnimFrameHandler=this.requestedRenderingAnimFrameHandler=0;this.renderedStream=this.videoCaptureElement=
this.mainVideoElement=null;this.videoCaptureStartTime=0;this.glanceVideoSourcebaseURL=null;this.useAudioTimerAnimation=this.skipRendering=!1;this.isAudioTimerAnimationSupported=!0;this.blurRadius=8;this.maskBlurRadius=3;this.maskThreshold=.4;this.tfliteDetectorWidth=256;this.tfliteDetectorHeight=144;this.maskWidth=256;this.maskHeight=144;this.bgEffectType="blur";this.resizeMaskOnReplacement=!0;"Safari"===GLANCE.Video.GlanceVideoSource.getBrowser()&&(this.isAudioTimerAnimationSupported=!1);this.blurInitialized=
!1;this.imageFillTexture=this.cameraTexture=this.maskTexture=this.copyShaderProg=this.maskedImageFillShaderProg=this.maskedColorFillShaderProg=this.maskBlurShaderProg=this.maskedBlurShaderProg=null;this.maskFBOs=[];this.activeMaskFBO=0;this.filterFBOs=[];this.activeFilterFBO=0;this.shaderVertexArray=new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]);this.ShaderTextureCoordsArray=new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]);this.YAxisMirroredShaderTextureCoordsArray=new Float32Array([0,1,1,1,0,0,0,0,
1,1,1,0]);this.vertexShaderSource="    // an attribute will receive data from a buffer\n    attribute vec4 a_position;\n    attribute vec2 a_texCoord;\n    varying vec2 v_texCoord;\n\n    void main() {\n      // gl_Position is a special variable a vertex shader\n      // is responsible for setting\n      gl_Position = a_position;\n      \n      // pass the texCoord to the fragment shader\n      // The GPU will interpolate this value between points\n      v_texCoord = a_texCoord;\n    }\n    ";this.MaskedBoxBlurFragmentShaderSource=
"\n      precision mediump float;\n      // our input texture, which is camera source\n      uniform sampler2D u_image;\n      uniform vec2 u_textureSize;\n      \n      // the blur mask\n      uniform sampler2D u_mask;\n      uniform vec2 u_maskSize;\n      \n      // the texCoords passed in from the vertex shader.\n      varying vec2 v_texCoord;\n\n      // horizontal pass?\n      uniform bool u_isHorizontalPass;\n      \n      // do we want to show mask for debug?\n      uniform bool u_showMask;\n        \n      void main() {\n      // compute 1 pixel in texture coordinates accounting for whether we are stepping horizontally or vertically\n      float hStep = 0.;\n      float vStep = 1.;\n      if (u_isHorizontalPass)\n      {\n          hStep = 1.0;\n          vStep = 0.;\n      }\n      vec2 onePixel = vec2(hStep, vStep) / u_textureSize;\n      \n      // can't find a way to pass this value in since loops are unrolled at compile time and we're stuck on WebGL 1 (Apple)\n      const int halfOrder = 10;\n      const int order = 2 * halfOrder + 1;\n      \n      const float kernelWeight = float(order);    \n      const float kernel = 1.0 / kernelWeight; \n\n      // if mask is zeroed, blur the color\n      // note mask is pre-blurred/filtered\n        vec4 maskColor = texture2D(u_mask, v_texCoord);\n        vec4 imageColor = texture2D(u_image, v_texCoord);\n        \n        float maskAlpha = maskColor.w;\n        \n      // if mask alpha is nearly 1.0, we don't blur, just use source color. This is the area inside the mask\n        if (maskAlpha >= 0.95)\n        {\n          gl_FragColor = imageColor;\n      }\n      else \n      {\n\n          vec4 colorSum = vec4(0.,0.,0.,0.);\n\n          colorSum = texture2D(u_image, v_texCoord) * kernel;\n          float fStep = 0.;\n\n          for (int step = 1; step <= halfOrder; step++) \n          {\n              fStep = float(step);\n              colorSum += texture2D(u_image, v_texCoord + onePixel * -fStep) * kernel;\n              colorSum += texture2D(u_image, v_texCoord + onePixel * fStep) * kernel;\n          }\n        \n        // if alpha of mask is not 0.0 blend blurred and unblurred pixels\n        if (maskAlpha >= 0.05)\n              {\n              vec4 unblurred = vec4((imageColor * maskAlpha).rgb, maskAlpha);\n              gl_FragColor = vec4((colorSum * (1.0 - maskAlpha)).rgb, 1.0 - maskAlpha) + unblurred;\n\n              }\n        else\n        {\n              gl_FragColor = vec4((colorSum).rgb, 1.0);\n          }  \n\n    }\n    \n    // for debugging\n    if (u_showMask) \n      {\n        gl_FragColor.b = maskAlpha;\n    }\n    }\n    ";
this.MaskedBoxBlurVariableRadiusFragmentShaderSource="\n      precision mediump float;\n      // our input texture, which is camera source\n      uniform sampler2D u_image;\n      uniform vec2 u_textureSize;\n      \n      // the blur mask\n      uniform sampler2D u_mask;\n      uniform vec2 u_maskSize;\n      \n      // the texCoords passed in from the vertex shader.\n      varying vec2 v_texCoord;\n      \n      // horizontal pass?\n      uniform bool u_isHorizontalPass;\n      \n      // do we want to show mask for debug?\n      uniform bool u_showMask;\n      \n      // this is the amount < halforder that we will actually use for shader radius\n      uniform float u_blurRadius;\n\n    void main() {\n    // compute 1 pixel in texture coordinates accounting for whether we are stepping horizontally or vertically\n    float hStep = 0.;\n    float vStep = 1.;\n    if (u_isHorizontalPass)\n    {\n        hStep = 1.0;\n        vStep = 0.;\n    }\n    vec2 onePixel = vec2(hStep, vStep) / u_textureSize;\n    \n    // loops are unrolled at shader compile time, so this is the maximum \n    // possible shader radius\n    const int halfOrder = 30;\n\n    // if mask is zeroed, blur the color\n    // note mask is pre-blurred/filtered\n      vec4 maskColor = texture2D(u_mask, v_texCoord);\n      vec4 imageColor = texture2D(u_image, v_texCoord);\n\n      float maskAlpha = maskColor.w;\n        \n    // if mask alpha is nearly 1.0, we don't blur, just use source color. This is the area inside the mask\n      if (maskAlpha >= 0.95)\n      {\n        gl_FragColor = imageColor;\n      }\n      else \n      {\n          vec4 colorSum = vec4(0.,0.,0.,0.);\n\n          float fStep = 0.;\n          \n          int radius = int(((1.0 - maskAlpha) * u_blurRadius)+0.5);\n          float order = 2. * float(radius) + 1.;\n\n          float kernel = 1.0 / order; \n          colorSum = texture2D(u_image, v_texCoord) * kernel;\n          // to make this variable weight I'll have to have an unrolled loop here of max half order I'll\n          // ever use, and skip the terms that are outside the range\n          for (int step = 1; step <= halfOrder; step++) \n        {\n            // because we are stuck using webGL1 this loop has been unrolled\n            // we need to skip the steps we don't want to take \n            if (step <= radius) \n            {\n              fStep = float(step);\n              colorSum += texture2D(u_image, v_texCoord + onePixel * -fStep) * kernel;\n              colorSum += texture2D(u_image, v_texCoord + onePixel * fStep) * kernel;\n            }\n            else \n            {\n                break;\n            }\n\n          }\n\n          gl_FragColor = vec4((colorSum).rgb, 1.0);\n        }\n\n    // for debugging\n    if (u_showMask) \n    {\n        gl_FragColor.b = maskAlpha;\n    }\n    }\n    ";
this.MaskBoxBlurFragmentShaderSource="\n      precision mediump float;\n      \n      // the blur mask\n      uniform sampler2D u_mask;\n      uniform vec2 u_maskSize;\n      \n      // the texCoords passed in from the vertex shader.\n      varying vec2 v_texCoord;\n\n      // horizontal pass?\n      uniform bool u_isHorizontalPass;\n      \n          \n      // this is the amount < halforder that we will actually use for shader radius\n      uniform float u_maskBlurRadius;\n\n\n    void main() {\n    // compute 1 pixel in texture coordinates accounting for whether we are stepping horizontally or vertically\n    float hStep = 0.;\n    float vStep = 1.;\n    if (u_isHorizontalPass)\n    {\n        hStep = 1.0;\n        vStep = 0.;\n    }\n    vec2 onePixel = vec2(hStep, vStep) / u_maskSize;\n\n    const int halfOrder = 20;\n    int radius = int((u_maskBlurRadius)+0.5);\n    float order = 2. * float(radius) + 1.;\n\n    float kernel = 1.0 / order; \n\n      vec4 colorSum = texture2D(u_mask, v_texCoord) * kernel;\n      float fStep = 0.;\n\n      for (int step = 1; step <= halfOrder; step++) \n      {\n          // because we are stuck using webGL1 this loop has been unrolled\n          // we need to skip the steps we don't want to take \n          if (step <= radius) \n          {\n            fStep = float(step);\n            colorSum += texture2D(u_mask, v_texCoord + onePixel * -fStep) * kernel;\n            colorSum += texture2D(u_mask, v_texCoord + onePixel * fStep) * kernel;\n          }\n          else \n          {\n              break;\n          }\n      }\n\n      gl_FragColor = colorSum;\n    }\n    ";
this.MaskedColorFillFragmentShaderSource="\n      precision mediump float;\n      // our input texture, which is camera source\n      uniform sampler2D u_image;\n      uniform vec2 u_textureSize;\n      \n      // the detection mask\n      uniform sampler2D u_mask;\n      \n      // the texCoords passed in from the vertex shader.\n      varying vec2 v_texCoord;\n\n      // fill color\n      uniform vec4 u_fillColor;\n      \n      // do we want to show mask for debug?\n      uniform bool u_showMask;\n\n      void main() {\n\n      // if mask is zeroed, use the fill color\n      // note mask is pre-blurred/filtered\n        vec4 maskColor = texture2D(u_mask, v_texCoord);\n        vec4 imageColor = texture2D(u_image, v_texCoord);\n        \n        float maskAlpha = maskColor.w;\n\n        gl_FragColor = u_fillColor * (1.0-maskAlpha) + imageColor * maskAlpha;\n      \n      // for debugging\n      if (u_showMask) \n      {\n          gl_FragColor.b = maskAlpha;\n      }\n      }\n      ";
this.MaskedImageFillFragmentShaderSource="\n    precision mediump float;\n    // our input texture, which is camera source\n    uniform sampler2D u_image;\n    uniform vec2 u_textureSize;\n\n    // the detection mask\n    uniform sampler2D u_mask;\n\n    // the replacement image \n    uniform sampler2D u_fillImage;\n\n    // the texCoords passed in from the vertex shader.\n    varying vec2 v_texCoord;\n\n    // do we want to show mask for debug?\n    uniform bool u_showMask;\n\n    void main() {\n\n      // if mask is zeroed, use the fill color\n      // note mask is pre-blurred/filtered\n        vec4 maskColor = texture2D(u_mask, v_texCoord);\n        vec4 imageColor = texture2D(u_image, v_texCoord);\n        vec4 fillImageColor = texture2D(u_fillImage, v_texCoord);\n        \n        float maskAlpha = maskColor.w;\n\n        gl_FragColor = fillImageColor * (1.0-maskAlpha) + imageColor * maskAlpha;\n      \n      // for debugging\n      if (u_showMask) \n      {\n          gl_FragColor.b = maskAlpha;\n      }\n    }\n    ";
this.copyFragmentShaderSource="// fragment shaders don't have a default precision so we need\n      // to pick one. mediump is a good default\n      precision mediump float;\n      // our texture\n      uniform sampler2D u_image;\n\n      // the texCoords passed in from the vertex shader.\n      varying vec2 v_texCoord;\n\n      void main() {\n\n        // just copy in to out\n        vec4 imageColor = texture2D(u_image, v_texCoord);\n\n        gl_FragColor = imageColor;\n      }\n      ";this.frameTimeReport=
null;this.runFilter=!1;this.segmentMask=this.segmentation=null;this.newMask=!1;this.requestedFrameRate=this.renderFrameRate=this.filterCount=this.filterAvg=this.detectCount=this.detectAvg=this.lastDetectFrameTime=this.lastRenderFrameTime=this.msPerFrame=0;this.inDetect=!1;this.detectionThrottleLimit=20;this.detectionThrottleFrameLimit=15;this.detectionThrottleFactor=this.detectionThrottleLimit;this.detectTimeLimit=500;this.detectionThrottleAvg=this.detectionThrottleFactor;this.detectionThrottleMin=
255;this.detectionThrottleMax=0;this.detectionThrottleLowerLimit=1;this.detectionThrottlePerformanceFailureReported=!1;this.detectionThrottlePerformanceFailureFrameThreshold=20;this.frameCount=this.frameAvg=this.detectionThrottlePerformanceFailureFrameCount=0;this.frameStartTime=performance.now();this.audioContext=null;this.runAudioLoop=!0;this.simdPossible="Chrome"===GLANCE.Video.GlanceVideoSource.getBrowser();this.resizeBuffer2dCtx=this.resizeBuffer=this.matchedSize=this.worker=null;this.tfLiteInitialized=
!1;this.detectionStartTime=performance.now();this.tempContext=this.tempCanvas=this.silence=null;window.addEventListener("visibilitychange",this.onVisibilityChanged.bind(this))}async initialize(){this.runFilter=this.bgBlurEnabled&&(this.bgEffectType?!0:!1);if(this.bgBlurEnabled){if(!GLANCE.Video.tfliteLoaded&&!GLANCE.Video.tfliteLoading){GLANCE.Video.tfliteLoading=!0;GLANCE.Video.tfliteWorkerBuffer=await this.fetch(this.glanceVideoSource.GVSbaseURL+"tflite/tflite-worker"+this.glanceVideoSource.GVSVersion,
"blob");try{GLANCE.Video.tfliteModelBuffer=await this.fetch(this.glanceVideoSource.GVSbaseURL+"tflite/selfie.bin")}catch(c){console.log("fetch() got selfie.bin reject, reading selfie.tflite"),GLANCE.Video.tfliteModelBuffer=await this.fetch(this.glanceVideoSource.GVSbaseURL+"tflite/selfie.tflite")}GLANCE.Video.tfliteWasmBuffer=this.simdPossible?await this.fetch(this.glanceVideoSource.GVSbaseURL+"tflite/tflite-simd.wasm"):await this.fetch(this.glanceVideoSource.GVSbaseURL+"tflite/tflite.wasm");GLANCE.Video.tfliteLoaded=
!0;GLANCE.Video.tfliteLoading=!1}let a=GLANCE.Lib.CleanContext.nativeClass("URL"),b=a.createObjectURL(GLANCE.Video.tfliteWorkerBuffer);this.worker=new Worker(b);a.revokeObjectURL(b);this.worker.onmessage=this.onmessage.bind(this);this.simdPossible?this.worker.postMessage({action:"wasm-simd",buffer:GLANCE.Video.tfliteWasmBuffer,modelBuffer:GLANCE.Video.tfliteModelBuffer}):this.worker.postMessage({action:"wasm",buffer:GLANCE.Video.tfliteWasmBuffer,modelBuffer:GLANCE.Video.tfliteModelBuffer});await this.waitForTfliteInitialization();
this.makeDetectionBuffer();this.videoCaptureStartTime=performance.now()}}get effectVideoCaptureElement(){return this.videoCaptureElement}get effectRenderedStream(){return this.renderedStream}get effectRenderedCanvas(){return this.renderedBuffer}get bGEffectSettings(){return{capable:this.bgBlurEnabled,active:this.runFilter,type:this.bgEffectType}}set skipEffectRendering(a){this.skipRendering=a}setBgFilterActive(a){this.runFilter=a&&this.bgBlurEnabled;this.runFilter||(this.detectCount=this.detectAvg=
0)}async loadBGImageURL(a){a?(null===this.bgImageElement&&(this.bgImageElement=document.createElement("img"),this.bgImageElement.id="GVbgImageElement",this.bgImageElement.style.display="none",this.bgImageElement.setAttribute("data-videopipeline","1"),this.bgImageElement.setAttribute("crossorigin","anonymous")),this.bgImageElement.onload=()=>this.bgImageLoaded=!0,this.bgImageElement.onerror=()=>{this.bgImageLoaded=!1;console.error("Unable to load bg image at URL - "+a)},this.bgImageElement.src=a,this.imageFillBitmap=
null):(console.error("cannot do background image fill without URL"),this.bgEffectType="fill")}async setBackgroundSettings(a,b,c){this.bgEffectType=a;"image"===a?(this.maskThreshold=.1,this.maskBlurRadius=1,await this.loadBGImageURL(c)):"fill"===a?(this.maskThreshold=.1,this.maskBlurRadius=1,this.bgColor=b):"blur"===a&&(this.maskThreshold=.4,this.maskBlurRadius=1,this.blurRadius=6);this.bgEffectType=a;this.worker&&this.worker.postMessage({action:"configure",threshold:this.maskThreshold});if(GLANCE.browserCapabilities.isAndroid||
GLANCE.browserCapabilities.isSafariIOS)this.detectionThrottlePerformanceFailureFrameThreshold=this.detectionThrottleLimit=10}resetPipelineSize(a,b,c,d,e){this.glanceVideoSource.orientationMustReset=!1;if(this.bgBlurEnabled&&this.renderedBuffer){const f=this.renderedBuffer.width,g=this.renderedBuffer.height;e?e=b:(e=a,a=b);b=c;let h=d;GLANCE.browserCapabilities.isSafariIOS&&c<d&&(b=d,h=c);if(e!=f||a!=g)this.renderedBuffer.width=e,this.renderedBuffer.height=a,"blur"!=this.bgEffectType&&(this.maskWidth=
this.renderedBuffer.width,this.maskHeight=this.renderedBuffer.height),GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("resetting pipeline to "+b+"/"+h)),this.makeFilterFBOs(this.renderBufferWebGLCtx,this.renderedBuffer.width,this.renderedBuffer.height),this.matchedSize=c=this.scaledMatchAspect(b,h,this.detectionMaxDimension),this.makeMaskFBOs(this.renderBufferWebGLCtx,this.maskWidth,this.maskHeight),GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("resetting detection to "+
c.width+"/"+c.height)),this.imageFillBitmap=null,this.renderedStream&&(this.renderedStream=this.renderedBuffer.captureStream())}}scaledMatchAspect(a,b,c){a/=b;1<=a?(b=c,c/=a):b=c*a;c>this.detectionBuffer.height&&(c=this.detectionBuffer.height,b=a*c);return{width:parseInt(b),height:parseInt(c)}}startRenderedStream(a){GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("startRenderedStream  frameRate is now - "+a));this.blurInitialized&&this.renderedBuffer&&(this.renderedStream=
this.renderedBuffer.captureStream())}StopRenderingStream(){this.stopRendering();this.videoCaptureElement&&this.videoCaptureElement!==this.mainVideoElement&&(this.videoCaptureElement.srcObject=null);this.renderedStream&&this.renderedStream.getTracks().forEach(a=>{a.stop()});this.renderedStream=null}async startVideoCapture(a,b){if(this.videoCaptureElement&&this.videoCaptureElement!==this.mainVideoElement)if(this.videoCaptureElement.setAttribute("autoplay",!0),this.videoCaptureElement.setAttribute("playsinline",
!0),this.videoCaptureElement.setAttribute("muted",!0),this.videoCaptureElement.srcObject=a,GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("Starting videoCaptureElement play")),this.videoCaptureElement.load(),(a=this.videoCaptureElement.play())&&"function"===typeof a.then)try{await a,GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("VideoCaptureElement playing")),this.startRenderedStream(b)}catch(c){console.error("videoCaptureElement.play() failed - "+
c)}else console.error("videoCaptureElement play failed: play function returned no Promise.")}makeDetectionBuffer(){this.detectionBuffer=document.createElement("canvas");this.detectionBuffer.id="GVdetectionCanvasBuffer";this.detectionBuffer.setAttribute("data-videopipeline","1");this.detectionBuffer2dCtx=this.detectionBuffer.getContext("2d");this.detectionBuffer.width=this.tfliteDetectorWidth;this.detectionBuffer.height=this.tfliteDetectorHeight;this.resizeBuffer=document.createElement("canvas");this.resizeBuffer.id=
"GVdetectionCanvasBufferResize";this.resizeBuffer.setAttribute("data-videopipeline","1");this.resizeBuffer2dCtx=this.resizeBuffer.getContext("2d");this.resizeBuffer.width=this.tfliteDetectorWidth;this.resizeBuffer.height=this.tfliteDetectorHeight}setupBGEffectElements(a){if(!a||a!==this.mainVideoElement){this.blurInitialized=!1;this.mainVideoElement=a;if(a){var b=a.closest("div");null==b&&(b=a.parentElement)}else b=document.body;if(this.bgBlurEnabled){null==this.videoCaptureElement&&(this.videoCaptureElement=
document.createElement("video"),this.videoCaptureElement.id="GVvideoCaptureElement",this.videoCaptureElement.style.display="none",this.videoCaptureElement.setAttribute("data-videopipeline","1"));if(null==this.renderedBuffer||null==this.renderBufferWebGLCtx){null!==this.renderedBuffer&&(this.renderedBuffer.remove(),this.renderedBuffer=null);this.renderedBuffer=document.createElement("canvas");this.renderedBuffer.id="GVrenderedBuffer";this.renderedBuffer.style.display="none";this.renderedBuffer.setAttribute("data-videopipeline",
"1");this.renderedBuffer.addEventListener("unload",c=>{this.glanceVideoSource.renderedStream&&this.glanceVideoSource.renderedStream.getTracks().forEach(d=>{d.stop()});this.glanceVideoSource.renderedStream=null});this.renderedBuffer.width=this.tfliteDetectorWidth;this.renderedBuffer.height=this.tfliteDetectorHeight;this.renderBufferWebGLCtx="Safari"===GLANCE.Video.GlanceVideoSource.getBrowser()?this.renderedBuffer.getContext("webgl2",{preserveDrawingBuffer:!0}):this.renderedBuffer.getContext("webgl2");
if(null==this.renderBufferWebGLCtx)throw{error:"WEBGL_CONTEXT_FAILED",message:"Couldn't create WebGL context. A browser restart may be neccessary."};this.initializeBlurPrograms();this.renderBufferWebGLCtx.enable(this.renderBufferWebGLCtx.CULL_FACE)}null==this.detectionBuffer&&this.makeDetectionBuffer();this.detectionBuffer2dCtx||(this.detectionBuffer2dCtx=this.detectionBuffer.getContext("2d"));this.blurInitialized=!0}}}onmessage(a){({data:a}=a);if("loaded"==a.action)this.tfLiteInitialized=!0;else if("simd-failed"==
a.action)this.fetch(this.glanceVideoSource.GVSbaseURL+"tflite/tflite.wasm").then(b=>{this.worker.postMessage({action:"wasm",buffer:b,modelBuffer:this.modelBuffer})});else if("mask"==a.action){a=new ImageData(new Uint8ClampedArray(a.pixels),a.width,a.height);if(this.matchedSize.width<this.detectionBuffer.width||this.matchedSize.height<this.detectionBuffer.height)this.resizeMaskOnReplacement=!1,this.resizeBuffer2dCtx.putImageData(a,0,0),a=this.resizeBuffer2dCtx.getImageData((this.detectionBuffer.width-
this.matchedSize.width)/2,this.detectionBuffer.height-this.matchedSize.height,this.matchedSize.width,this.matchedSize.height);this.segmentMask=a;this.newMask=null!==this.segmentMask;this.inDetect=!1;this.newMask&&(this.detectCount++,a=performance.now(),this.detectAvg+=(a-this.detectionStartTime-this.detectAvg)/Math.min(this.detectCount,10),1===this.detectCount&&(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("Time to first detection - "+(Math.trunc(100*(a-this.videoCaptureStartTime))/
100).toString()+"ms")),GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("First segmentPerson took - "+(Math.trunc(100*(a-this.detectionStartTime))/100).toString()+"ms"))))}}waitForTfliteInitialization(){return new Promise((a,b)=>{this.tfLiteInitialized?a():setTimeout(()=>{this.checkTfliteInitialization(a,b)},10)})}checkTfliteInitialization(a,b){this.tfLiteInitialized?a():setTimeout(()=>{this.checkTfliteInitialization(a,b)},10)}async fetch(a,b){return new Promise((c,d)=>
{var e=new XMLHttpRequest;e.open("GET",a,!0);e.responseType=b?"blob":"arraybuffer";e.onerror=function(f){console.warn("fetch URL"+a+" onerror called");d()};e.onload=function(f){f=e.response;200===e.status&&f?c(f):d()};e.send(null)})}initializeBlurPrograms(){let a=this.createShader(this.renderBufferWebGLCtx,this.renderBufferWebGLCtx.VERTEX_SHADER,this.vertexShaderSource),b=this.createShader(this.renderBufferWebGLCtx,this.renderBufferWebGLCtx.FRAGMENT_SHADER,this.MaskedBoxBlurVariableRadiusFragmentShaderSource);
this.maskedBlurShaderProg=this.createProgram(this.renderBufferWebGLCtx,a,b);b=this.createShader(this.renderBufferWebGLCtx,this.renderBufferWebGLCtx.FRAGMENT_SHADER,this.MaskBoxBlurFragmentShaderSource);this.maskBlurShaderProg=this.createProgram(this.renderBufferWebGLCtx,a,b);b=this.createShader(this.renderBufferWebGLCtx,this.renderBufferWebGLCtx.FRAGMENT_SHADER,this.MaskedColorFillFragmentShaderSource);this.maskedColorFillShaderProg=this.createProgram(this.renderBufferWebGLCtx,a,b);b=this.createShader(this.renderBufferWebGLCtx,
this.renderBufferWebGLCtx.FRAGMENT_SHADER,this.MaskedImageFillFragmentShaderSource);this.maskedImageFillShaderProg=this.createProgram(this.renderBufferWebGLCtx,a,b);b=this.createShader(this.renderBufferWebGLCtx,this.renderBufferWebGLCtx.FRAGMENT_SHADER,this.copyFragmentShaderSource);this.copyShaderProg=this.createProgram(this.renderBufferWebGLCtx,a,b);this.maskTexture=this.renderBufferWebGLCtx.createTexture();this.cameraTexture=this.renderBufferWebGLCtx.createTexture();this.imageFillTexture=this.renderBufferWebGLCtx.createTexture()}switchShaderProgram(a,
b,c){this.renderBufferWebGLCtx.useProgram(a);var d=this.renderBufferWebGLCtx.getAttribLocation(a,"a_position");let e=this.renderBufferWebGLCtx.createBuffer();this.renderBufferWebGLCtx.bindBuffer(this.renderBufferWebGLCtx.ARRAY_BUFFER,e);this.renderBufferWebGLCtx.bufferData(this.renderBufferWebGLCtx.ARRAY_BUFFER,this.shaderVertexArray,this.renderBufferWebGLCtx.STATIC_DRAW);this.renderBufferWebGLCtx.enableVertexAttribArray(d);this.renderBufferWebGLCtx.vertexAttribPointer(d,2,this.renderBufferWebGLCtx.FLOAT,
!1,0,0);b&&(b=this.renderBufferWebGLCtx.getUniformLocation(a,"u_textureSize"),d=this.renderBufferWebGLCtx.getUniformLocation(a,"u_image"),this.renderBufferWebGLCtx.uniform2f(b,this.videoCaptureElement.videoWidth,this.videoCaptureElement.videoHeight),this.renderBufferWebGLCtx.uniform1i(d,0));c&&(c=this.renderBufferWebGLCtx.getUniformLocation(a,"u_maskSize"),this.renderBufferWebGLCtx.uniform2f(c,this.maskWidth,this.maskHeight),a=this.renderBufferWebGLCtx.getUniformLocation(a,"u_mask"),this.renderBufferWebGLCtx.uniform1i(a,
1))}createShader(a,b,c){b=a.createShader(b);a.shaderSource(b,c);a.compileShader(b);if(a.getShaderParameter(b,a.COMPILE_STATUS))return b;GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter(a.getShaderInfoLog(b)));a.deleteShader(b)}createProgram(a,b,c){let d=a.createProgram();a.attachShader(d,b);a.attachShader(d,c);a.linkProgram(d);if(a.getProgramParameter(d,a.LINK_STATUS))return d;GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter(a.getProgramInfoLog(d)));
a.deleteProgram(d)}setupFilterPass(a,b,c,d,e,f){if(null!==e){let g=a.getUniformLocation(b,"u_isHorizontalPass");a.uniform1i(g,e)}e=a.getUniformLocation(b,"u_showMask");a.uniform1i(e,GLANCE.Video.drawTrackingData);e=a.getUniformLocation(b,"u_blurRadius");a.uniform1f(e,this.blurRadius);e=a.getUniformLocation(b,"u_maskBlurRadius");a.uniform1f(e,this.maskBlurRadius);b=a.getAttribLocation(b,"a_texCoord");e=a.createBuffer();a.bindBuffer(a.ARRAY_BUFFER,e);f?a.bufferData(a.ARRAY_BUFFER,this.YAxisMirroredShaderTextureCoordsArray,
a.STATIC_DRAW):a.bufferData(a.ARRAY_BUFFER,this.ShaderTextureCoordsArray,a.STATIC_DRAW);a.enableVertexAttribArray(b);a.vertexAttribPointer(b,2,a.FLOAT,!1,0,0);c&&(a.activeTexture(a.TEXTURE0),a.bindTexture(a.TEXTURE_2D,c),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST));d&&(a.activeTexture(a.TEXTURE1),
a.bindTexture(a.TEXTURE_2D,d),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.NEAREST),a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.NEAREST))}makeFramebuffer(a,b,c){let d=a.createTexture();a.bindTexture(a.TEXTURE_2D,d);a.texImage2D(a.TEXTURE_2D,0,a.RGBA,b,c,0,a.RGBA,a.UNSIGNED_BYTE,null);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_WRAP_S,a.CLAMP_TO_EDGE);a.texParameteri(a.TEXTURE_2D,
a.TEXTURE_WRAP_T,a.CLAMP_TO_EDGE);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MIN_FILTER,a.LINEAR);a.texParameteri(a.TEXTURE_2D,a.TEXTURE_MAG_FILTER,a.LINEAR);b=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,b);a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,d,0);b.texture=d;a.clearColor(0,0,0,0);a.clear(this.renderBufferWebGLCtx.COLOR_BUFFER_BIT);a.bindFramebuffer(a.FRAMEBUFFER,null);a.bindTexture(a.TEXTURE_2D,null);a.bindRenderbuffer(a.RENDERBUFFER,null);return b}makeMaskFBOs(a,
b,c){this.maskFBOs[0]=this.makeFramebuffer(a,b,c);this.maskFBOs[1]=this.makeFramebuffer(a,b,c)}makeFilterFBOs(a,b,c){this.filterFBOs[0]=this.makeFramebuffer(a,b,c);this.filterFBOs[1]=this.makeFramebuffer(a,b,c)}startupRendering(a){this.blurInitialized&&(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("startupRendering with framerate - "+a)),this.requestedFrameRate=a,this.msPerFrame=1E3/a,this.lastRenderFrameTime=performance.now(),this.lastDetectFrameTime=performance.now(),
a=async()=>{await this.renderLoop();await this.detectionLoop()},this.useAudioTimerAnimation?this.audioTimerLoop(a,1E3/60):(this.requestedRenderingAnimFrameHandler&&(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("startupRendering canceling requestAnimationFrame")),cancelAnimationFrame(this.requestedRenderingAnimFrameHandler),this.requestedRenderingAnimFrameHandler=null),this.requestedDetectionAnimFrameHandler&&(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("startupRendering canceling requestedDetectionAnimFrameHandler")),
cancelAnimationFrame(this.requestedDetectionAnimFrameHandler),this.requestedDetectionAnimFrameHandler=null),a(this)),!this.frameTimeReport&&GLANCE.Video.VideoDebug&&(this.frameTimeReport=window.setInterval(()=>{console.log(this.glanceVideoSource.videoLogFormatter("Rendered Framerate - "+this.renderFrameRate.toString()+" DetectTime - "+(Math.trunc(100*this.detectAvg)/100).toString()+"ms Filtertime - "+(Math.trunc(100*this.filterAvg)/100).toString()+"ms detectionThrottleMin/Max - "+this.detectionThrottleMin/
this.detectionThrottleLimit+"/"+this.detectionThrottleMax/this.detectionThrottleLimit+" detectionThrottleFactor - "+(Math.trunc(this.detectionThrottleAvg/this.detectionThrottleLimit*100)/100).toString()));this.detectionThrottleMin=255;this.detectionThrottleMax=0},1E4)))}stopRendering(){this.useAudioTimerAnimation?this.runAudioLoop=!1:(this.requestedRenderingAnimFrameHandler&&(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("stopRendering canceling requestedRenderingAnimFrameHandler")),
cancelAnimationFrame(this.requestedRenderingAnimFrameHandler),this.requestedRenderingAnimFrameHandler=null),this.requestedDetectionAnimFrameHandler&&(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("stopRendering canceling requestedDetectionAnimFrameHandler")),cancelAnimationFrame(this.requestedDetectionAnimFrameHandler),this.requestedDetectionAnimFrameHandler=null));this.frameTimeReport&&(window.clearInterval(this.frameTimeReport),this.frameTimeReport=null)}onVisibilityChanged(a){this.isAudioTimerAnimationSupported&&
(a=async()=>{await this.renderLoop();await this.detectionLoop()},this.requestedRenderingAnimFrameHandler&&(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("startupRendering canceling requestAnimationFrame")),cancelAnimationFrame(this.requestedRenderingAnimFrameHandler),this.requestedRenderingAnimFrameHandler=null),this.requestedDetectionAnimFrameHandler&&(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("startupRendering canceling requestedDetectionAnimFrameHandler")),
cancelAnimationFrame(this.requestedDetectionAnimFrameHandler),this.requestedDetectionAnimFrameHandler=null),document.hidden?(this.useAudioTimerAnimation=!0,this.audioTimerLoop(a,1E3/60)):(this.useAudioTimerAnimation=!1,a(this)))}audioTimerLoop(a,b){let c=b/1E3;this.audioContext||(this.audioContext=new AudioContext,this.silence=this.audioContext.createGain(),this.silence.gain.value=0,this.silence.connect(this.audioContext.destination));const d=()=>{if(this.useAudioTimerAnimation){var e=this.audioContext.createOscillator();
e.onended=d;e.connect(this.silence);e.start(0);e.stop(this.audioContext.currentTime+c);this.runAudioLoop&&a(this.audioContext.currentTime)}};d();this.runAudioLoop=!0}async renderLoop(a){a=performance.now();let b=a-this.lastRenderFrameTime;b>=this.msPerFrame&&(this.lastRenderFrameTime=a-b%this.msPerFrame,this.blurInitialized&&!this.skipRendering&&await this.processVideoFrame(a));this.useAudioTimerAnimation||(this.requestedRenderingAnimFrameHandler=requestAnimationFrame(this.renderLoop.bind(this)))}async detectionLoop(a){a=
performance.now();let b=a-this.lastDetectFrameTime,c=this.msPerFrame/(this.detectionThrottleFactor/this.detectionThrottleLimit);if(b>=c&&!this.inDetect){let d=this.renderFrameRate;this.detectAvg>this.detectTimeLimit||this.requestedFrameRate-d>this.requestedFrameRate/20?this.detectionThrottleFactor>this.detectionThrottleLowerLimit?--this.detectionThrottleFactor:(this.detectionThrottlePerformanceFailureFrameCount++,this.runFilter&&this.detectionThrottlePerformanceFailureFrameCount>=this.detectionThrottlePerformanceFailureFrameThreshold&&
(this.requestedFrameRate>this.detectionThrottleFrameLimit?(this.detectionThrottlePerformanceFailureFrameCount=0,this.glanceVideoSource.stepDownPerformanceProfile(),await this.glanceVideoSource.restartVideoStream({})):this.detectionThrottlePerformanceFailureReported||(GLANCE.Video.VideoDebug&&console.log(this.glanceVideoSource.videoLogFormatter("Firing event bgFilterPerformanceFail")),this.glanceVideoSource.fireEvent("bgFilterPerformanceFail"),this.detectionThrottlePerformanceFailureReported=!0))):
this.detectionThrottleFactor<this.detectionThrottleLimit&&(this.detectionThrottleFactor+=1,this.detectionThrottlePerformanceFailureFrameCount=0);this.detectionThrottleMin=Math.min(this.detectionThrottleMin,this.detectionThrottleFactor);this.detectionThrottleMax=Math.max(this.detectionThrottleMax,this.detectionThrottleFactor);this.detectionThrottleAvg+=(this.detectionThrottleFactor-this.detectionThrottleAvg)/Math.min(this.detectCount?this.detectCount:1,10);this.lastDetectFrameTime=a-b%c;this.blurInitialized&&
!this.skipRendering&&await this.runDetector(a)}this.useAudioTimerAnimation||(this.requestedDetectionAnimFrameHandler=requestAnimationFrame(this.detectionLoop.bind(this)))}callDetect(){if(this.worker&&this.detectionBuffer2dCtx){let a=this.detectionBuffer.width,b=this.detectionBuffer.height;const c=this.detectionBuffer2dCtx.getImageData(0,0,a,b);this.worker.postMessage({action:"pixels",pixels:c.data.buffer,width:a,height:b,channels:4},[c.data.buffer])}}async runDetector(a){0<this.videoCaptureElement.videoWidth&&
0<this.videoCaptureElement.videoHeight&&this.runFilter&&this.worker&&!this.inDetect&&(this.inDetect=!0,this.detectionStartTime=performance.now(),this.detectionBuffer2dCtx.drawImage(this.videoCaptureElement,0,0,this.videoCaptureElement.videoWidth,this.videoCaptureElement.videoHeight,(this.detectionBuffer.width-this.matchedSize.width)/2,this.detectionBuffer.height-this.matchedSize.height,this.matchedSize.width,this.matchedSize.height),this.callDetect())}async processVideoFrame(a){if(!(0>=this.videoCaptureElement.videoWidth||
0>=this.videoCaptureElement.videoHeight))if(this.frameCount++,a=a?a:performance.now(),this.frameAvg+=(a-this.frameStartTime-this.frameAvg)/Math.min(this.frameCount,10),this.renderFrameRate=Math.trunc(1E3/this.frameAvg*100)/100,this.frameStartTime=a,this.runFilter&&0<this.detectCount){this.filterCount++;a=performance.now();this.segmentMask&&this.newMask&&("blur"!=this.bgEffectType&&this.resizeMaskOnReplacement&&(this.segmentMask=await this.resizeMask()),this.blurDetectedMask(),this.segmentMask=null,
this.newMask=!1);"blur"===this.bgEffectType?this.blurBackground(this.activeMaskFBO):"fill"===this.bgEffectType?await this.colorFillBackground(this.activeMaskFBO):"image"===this.bgEffectType?await this.imageFillBackground(this.activeMaskFBO):console.error("Invalid background effect type - "+this.bgEffectType);let b=performance.now();this.filterAvg+=(b-a-this.filterAvg)/Math.min(this.filterCount,10)}else this.runFilter||(this.switchShaderProgram(this.copyShaderProg,this.cameraTexture,null),this.setupFilterPass(this.renderBufferWebGLCtx,
this.copyShaderProg,this.cameraTexture,null,null,!0),this.renderBufferWebGLCtx.activeTexture(this.renderBufferWebGLCtx.TEXTURE0),this.renderBufferWebGLCtx.texImage2D(this.renderBufferWebGLCtx.TEXTURE_2D,0,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.UNSIGNED_BYTE,this.videoCaptureElement),this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,null),this.renderBufferWebGLCtx.viewport(0,0,this.renderedBuffer.width,this.renderedBuffer.height),
this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6))}blurDetectedMask(){this.switchShaderProgram(this.maskBlurShaderProg,null,this.maskTexture,!0);this.setupFilterPass(this.renderBufferWebGLCtx,this.maskBlurShaderProg,null,this.maskTexture,!0,!0);this.renderBufferWebGLCtx.activeTexture(this.renderBufferWebGLCtx.TEXTURE1);this.renderBufferWebGLCtx.texImage2D(this.renderBufferWebGLCtx.TEXTURE_2D,0,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.UNSIGNED_BYTE,
this.segmentMask);this.activeMaskFBO=0;this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,this.maskFBOs[this.activeMaskFBO]);this.renderBufferWebGLCtx.viewport(0,0,this.maskWidth,this.maskHeight);this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6);this.activeMaskFBO=1;this.setupFilterPass(this.renderBufferWebGLCtx,this.maskBlurShaderProg,null,this.maskFBOs[0].texture,!1,!0);this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,
this.maskFBOs[this.activeMaskFBO]);this.renderBufferWebGLCtx.viewport(0,0,this.maskWidth,this.maskHeight);this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6);return this.activeMaskFBO}async resizeMask(){this.tempCanvas||(this.tempCanvas=document.createElement("canvas"),this.tempContext=this.tempCanvas.getContext("2d"));this.tempCanvas.width=this.renderedBuffer.width;this.tempCanvas.height=this.renderedBuffer.height;this.resizeBuffer2dCtx.putImageData(this.segmentMask,0,0);
this.tempContext.drawImage(this.resizeBuffer,0,0,this.resizeBuffer.width,this.resizeBuffer.height,0,0,this.renderedBuffer.width,this.renderedBuffer.height);let a=this.tempContext.getImageData(0,0,this.renderedBuffer.width,this.renderedBuffer.height);this.tempContext.clearRect(0,0,this.tempCanvas.width,this.tempCanvas.height);return a}blurBackground(a){this.switchShaderProgram(this.maskedBlurShaderProg,this.cameraTexture,this.maskFBOs[a].texture);this.setupFilterPass(this.renderBufferWebGLCtx,this.maskedBlurShaderProg,
this.cameraTexture,this.maskFBOs[a].texture,!0,!1);this.renderBufferWebGLCtx.activeTexture(this.renderBufferWebGLCtx.TEXTURE0);this.renderBufferWebGLCtx.texImage2D(this.renderBufferWebGLCtx.TEXTURE_2D,0,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.UNSIGNED_BYTE,this.videoCaptureElement);this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,this.filterFBOs[0]);this.renderBufferWebGLCtx.viewport(0,0,this.renderedBuffer.width,this.renderedBuffer.height);
this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6);this.setupFilterPass(this.renderBufferWebGLCtx,this.maskedBlurShaderProg,this.filterFBOs[0].texture,this.maskFBOs[a].texture,!1,!1);this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,this.filterFBOs[1]);this.renderBufferWebGLCtx.viewport(0,0,this.renderedBuffer.width,this.renderedBuffer.height);this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6);this.setupFilterPass(this.renderBufferWebGLCtx,
this.maskedBlurShaderProg,this.filterFBOs[1].texture,this.maskFBOs[a].texture,!0,!1);this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,this.filterFBOs[0]);this.renderBufferWebGLCtx.viewport(0,0,this.renderedBuffer.width,this.renderedBuffer.height);this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6);this.setupFilterPass(this.renderBufferWebGLCtx,this.maskedBlurShaderProg,this.filterFBOs[0].texture,this.maskFBOs[a].texture,!1,!0);this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,
null);this.renderBufferWebGLCtx.viewport(0,0,this.renderedBuffer.width,this.renderedBuffer.height);this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6)}hexToRgb(a){return(a=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(a))?{r:parseInt(a[1],16),g:parseInt(a[2],16),b:parseInt(a[3],16)}:null}async colorFillBackground(a){this.switchShaderProgram(this.maskedColorFillShaderProg,this.cameraTexture,this.maskFBOs[a].texture);this.setupFilterPass(this.renderBufferWebGLCtx,this.maskedColorFillShaderProg,
this.cameraTexture,this.maskFBOs[a].texture,null,!0);this.renderBufferWebGLCtx.activeTexture(this.renderBufferWebGLCtx.TEXTURE0);this.renderBufferWebGLCtx.texImage2D(this.renderBufferWebGLCtx.TEXTURE_2D,0,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.UNSIGNED_BYTE,this.videoCaptureElement);a=this.hexToRgb(this.bgColor);a=[a.r/255,a.g/255,a.b/255,1];let b=this.renderBufferWebGLCtx.getUniformLocation(this.maskedColorFillShaderProg,"u_fillColor");this.renderBufferWebGLCtx.uniform4fv(b,
a);this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,null);this.renderBufferWebGLCtx.viewport(0,0,this.renderedBuffer.width,this.renderedBuffer.height);this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6)}async imageFillBackground(a){if(this.bgImageElement.complete&&this.bgImageLoaded){if(null===this.imageFillBitmap){var b=this.renderedBuffer.width/this.renderedBuffer.height;let c,d,e;this.bgImageElement.width/this.bgImageElement.height>b?(d=
this.bgImageElement.height,c=d*b,b=.5*(this.bgImageElement.width-c),e=0):(c=this.bgImageElement.width,d=c/b,b=0,e=.5*(this.bgImageElement.height-d));this.imageFillBitmap=await createImageBitmap(this.bgImageElement,b,e,c,d,{resizeWidth:this.renderedBuffer.width,resizeHeight:this.renderedBuffer.height})}this.switchShaderProgram(this.maskedImageFillShaderProg,this.cameraTexture,this.maskFBOs[a].texture);this.setupFilterPass(this.renderBufferWebGLCtx,this.maskedImageFillShaderProg,this.cameraTexture,
this.maskFBOs[a].texture,null,!0);this.renderBufferWebGLCtx.activeTexture(this.renderBufferWebGLCtx.TEXTURE0);this.renderBufferWebGLCtx.texImage2D(this.renderBufferWebGLCtx.TEXTURE_2D,0,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.UNSIGNED_BYTE,this.videoCaptureElement);a=this.renderBufferWebGLCtx.getUniformLocation(this.maskedImageFillShaderProg,"u_fillImage");this.renderBufferWebGLCtx.uniform1i(a,2);this.renderBufferWebGLCtx.activeTexture(this.renderBufferWebGLCtx.TEXTURE2);
this.renderBufferWebGLCtx.bindTexture(this.renderBufferWebGLCtx.TEXTURE_2D,this.imageFillTexture);this.renderBufferWebGLCtx.texParameteri(this.renderBufferWebGLCtx.TEXTURE_2D,this.renderBufferWebGLCtx.TEXTURE_WRAP_S,this.renderBufferWebGLCtx.CLAMP_TO_EDGE);this.renderBufferWebGLCtx.texParameteri(this.renderBufferWebGLCtx.TEXTURE_2D,this.renderBufferWebGLCtx.TEXTURE_WRAP_T,this.renderBufferWebGLCtx.CLAMP_TO_EDGE);this.renderBufferWebGLCtx.texParameteri(this.renderBufferWebGLCtx.TEXTURE_2D,this.renderBufferWebGLCtx.TEXTURE_MIN_FILTER,
this.renderBufferWebGLCtx.NEAREST);this.renderBufferWebGLCtx.texImage2D(this.renderBufferWebGLCtx.TEXTURE_2D,0,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.RGBA,this.renderBufferWebGLCtx.UNSIGNED_BYTE,this.imageFillBitmap);this.renderBufferWebGLCtx.bindFramebuffer(this.renderBufferWebGLCtx.FRAMEBUFFER,null);this.renderBufferWebGLCtx.viewport(0,0,this.renderedBuffer.width,this.renderedBuffer.height);this.renderBufferWebGLCtx.drawArrays(this.renderBufferWebGLCtx.TRIANGLES,0,6)}}};}).call(window);
//# sourceMappingURL=map.js.map
